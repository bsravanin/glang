# Initializes a SymbolTable with Gramola's builtin types, methods and functions.
#
# NOTES:
# - These are just prototypes for the symbol table, no implementations needed
# - return type for init's are ignored, but must be present anyway

# TODO: make sure all supported builtins are here


class object():

	def void __init__(object obj):
		pass


class void():
	pass


class int(object):

	def void __init__(object obj):
		# Integer.parseInt(x.toString()) ???
		pass


class bool(int):

	def void __init__(object obj):
		# Casting to boolean is a pain in Java, so we do it in Python
		# before generating the result
		pass


bool False = bool(0)
bool True = bool(1)


class float(object):

	def void __init__(object obj):
		# TODO: cast to float in codegen?
		# Float.parseFloat(x.toString())
		pass


class str(object):

	def void __init__(object obj):
		# String.valueOf
		pass

	def str copy():
		# String.clone
		pass

	def bool ends_with(str s):
		# String.endsWith
		pass

	def list find(str s):
		# String.indexOf
		pass

	def str lower():
		# String.toLowerCase
		pass

	def str replace(str s, str t):
		# String.replace
		pass

	def int rfind(str s):
		# String.lastIndexOf
		pass

	def list split(str s):
		# String.split
		pass

	def bool startswith(str s):
		# String.startsWith
		pass

	def str strip():
		# String.trim
		pass

	def str substring(int start, int end):
		# String.substring
		pass

	def str upper():
		# String.toUpperCase
		pass


class list(object):

	def void __init__(object obj):
		# ArrayList<Object>
		pass

	def bool append(object obj):
		# ArrayList<Object>.add
		pass

	def bool contains(object obj):
		# ArrayList<Object>.contains
		pass

	def list copy():
		# ArrayList<Object>.clone
		pass

	def bool extend(list l):
		# ArrayList<Object>.addAll
		pass

	def int index(object obj):
		# ArrayList<Object>.indexOf
		pass

	def void insert(int pos, object obj):
		# ArrayList<Object>.add
		pass

	def object pop(int pos):
		# ArrayList<Object>.remove
		pass

	def bool remove(object obj):
		# ArrayList<Object>.remove
		pass

	# TODO: find a way to support non-ArrayList methods
	#def void reverse():
	#	# Collections.reverse
	#	pass
	#
	#def void sort():
	#	# Collections.sort
	#	pass


class set(object):

	def void __init__(object obj):
		# HashSet<Object>
		pass

	def bool add(object obj):
		# HashSet<Object>.add
		pass

	def bool contains(object obj):
		# HashSet<Object>.contains
		pass

	def set copy():
		# HashSet<Object>.clone
		pass

	def bool difference_update(set s):
		# HashSet<Object>.removeAll
		pass

	def bool intersection_update(set s):
		# HashSet<Object>.retainAll
		pass

	def bool isempty():
		pass

	def bool issuperset(set s):
		# HashSet<Object>.containsAll
		pass

	def bool remove(object obj):
		# HashSet<Object>.remove
		pass

	def bool update(set s):
		# HashSet<Object>.addAll
		pass


class dict(object):

	def void __init__(object obj):
		# HashMap<Object,Object>
		pass

	def dict copy():
		# HashMap<Object,Object>.clone
		pass

	def object get(object key):
		# HashMap<Object,Object>.get
		pass

	def bool has_key(object key):
		# HashMap<Object,Object>.containsKey
		pass

	def set items():
		# HashMap<Object,Object>.entrySet
		pass

	def set keys():
		# HashMap<Object,Object>.keySet
		pass

	def object pop(object key):
		# HashMap<Object,Object>.remove
		pass

	def void update(dict d):
		# HashMap<Object,Object>.putAll
		pass

	def set values():
		# HashMap<Object,Object>.values
		pass


class Graph(object):

	def void __init__():
		pass

	# TODO: Java returns this as long. Should we translate all ints to long?
	def int get_id():
		pass

	def Node node(dict attr_dict):
		pass

	def Edge edge(Node start, Node end, dict attr_dict):
		pass

	def void add_node(Node n):
		pass

	def Node get_node(str variable, object value):
		pass

	def NodeSet get_nodes(str variable, object value):
		pass

	def Node get_node_by_id(int node_id):
		pass

	def list get_all_nodes():
		pass

	def void add_edge(Edge e):
		pass

	def list get_all_edges():
		pass

	def list get_shortest_path(Node start, Node end, dict attr_map):
		pass

	def list get_paths(Node start, Node end, dict attr_map):
		pass


class Node(object):

	def void __init__(dict attr_map):
		pass

	def void set_id(int node_id):
		pass

	def int get_id():
		pass

	def object get_attribute(str variable):
		pass

	def void set_attribute(str variable, object value):
		pass

	def set get_attributes():
		pass

	def dict get_attribute_dict():
		pass

	def void set_in_edge(Edge e):
		pass

	def void set_out_edge(Edge e):
		pass

	def EdgeSet out_edges():
		pass

	def EdgeSet in_edges():
		pass

	def NodeSet in_neighbors():
		pass

	def NodeSet out_neighbors():
		pass

	def void update(str variable, object new_value):
		pass


class Edge(object):

	def void __init__(Node start, Node end, dict var_map, int edge_id):
		pass

	def void set_id(int edge_id):
		pass

	def int get_id():
		pass

	def Node in_node():
		pass

	def Node out_node():
		pass

	def set get_attributes():
		pass

	def dict get_attribute_dict():
		pass

	def object get_attribute(str variable):
		pass

	def void set_attribute(str variable, object value):
		pass

	def void add_parents(Edge path_parent):
		pass

	def dict get_parents():
		pass


class NodeSet(set):

	def NodeSet filter(str variable, object value):
		pass

	def EdgeSet out_edges():
		pass


class EdgeSet(set):

	def EdgeSet filter(str variable, object value):
		pass

	def NodeSet out_nodes():
		pass


class Path(list):

	def void __init__(object obj):
		pass


class __builtins(object):

	def int len(object obj):
		pass

	def Graph load(str path):
		pass

	def void dump(Graph g, str path):
		pass

	def void draw(Graph g, str node_attr, str edge_attr):
		pass
